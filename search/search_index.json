{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EE5419 Advanced Control Laboratory \u2013 IIT Madras","text":"<p>This is a guide for experiments related to ROS in the EE5419 Advanced Control Laboratory course at IIT Madras.</p> <p>For the original documentation visit original docs.</p>"},{"location":"#theory","title":"Theory","text":"<p>Robot Operating System (ROS) is an open-source framework widely used in both research and industry for robotic system development. While it's called an \"operating system,\" ROS is actually a middleware that runs on top of Linux-based systems such as Ubuntu.</p> <p>It simplifies communication between different components of a robotic system\u2014like sensors, actuators, and controllers.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Node-based Communication: Components (called nodes) communicate using topics, services, or actions.</li> <li>Standardized Libraries: Offers pre-built libraries for tasks such as motion planning, navigation, and perception.</li> <li>Simulators: Integrates with simulators like Gazebo for testing robot behavior in virtual environments.</li> <li>Modularity: Facilitates easy integration of various hardware and software components.</li> <li>Community Support: Backed by a large community with rich documentation and numerous open-source packages.</li> </ul>"},{"location":"#ros-versions","title":"ROS Versions","text":"<ul> <li>ROS 1: The original version, still widely used.</li> <li>ROS 2: Offers better real-time support, enhanced security, and improved multi-robot communication. Designed to meet the demands of modern robotic systems.</li> </ul>"},{"location":"#tested-configuration","title":"Tested Configuration","text":"<ul> <li>Operating System: Ubuntu 20.04.6 LTS</li> <li>ROS Version: ROS Noetic Ninjemys</li> <li>Python Version: Python 3.8.10</li> </ul> <p>You are advised to use the same configuration for this course but you are free to use any other configuration as long as you can run the code provided in this repository.</p>"},{"location":"about/","title":"About","text":"<p>This documentation was made purely for personal use. It is a work in progress and may contain inaccuracies or incomplete information. The author is not responsible for any errors or omissions in the documentation.</p> <p>The documentation is intended to be a reference for the author's own projects and may not be suitable for others. Use at your own risk.</p> <p>The author encourages feedback and contributions to improve the documentation, but does not guarantee that all suggestions will be implemented.</p>"},{"location":"about/#contributors","title":"Contributors","text":"<p>KingBenny101</p>"},{"location":"getting_started/","title":"Getting Started with ROS","text":""},{"location":"getting_started/#objectives","title":"Objectives","text":"<ul> <li>Learn how to install Ubuntu, ROS, and necessary dependencies</li> <li>Understand basic ROS tutorials related to Nodes and their communication</li> <li>Learn to use <code>rqt_graph</code></li> <li>Gain knowledge of ROS services, topics, and related concepts</li> </ul>"},{"location":"getting_started/#ubuntu-installation","title":"Ubuntu Installation","text":"<p>Install Ubuntu either directly as the OS or through a virtual machine. However, it is recommended to install it directly on your system for better performance. VMs can be slow and might need extra network configuration.</p>"},{"location":"getting_started/#resource-codes","title":"Resource Codes","text":"<p>Access the resource codes from this Google Drive folder.</p>"},{"location":"getting_started/#instructional-videos","title":"Instructional Videos","text":"<p>Watch the following videos:</p> <ul> <li>Video 1</li> <li>Video 2</li> <li>Video 3</li> <li>Video 4</li> </ul>"},{"location":"getting_started/#reference-links-for-installation-in-virtualbox","title":"Reference Links for Installation in VirtualBox","text":"<ul> <li>Installation Guide (PDF)</li> <li>Installation Tutorial (YouTube)</li> </ul>"},{"location":"getting_started/#reference-links-for-direct-ubuntu-os-installation","title":"Reference Links for Direct Ubuntu OS Installation","text":"<ul> <li>Installation Guide (PDF)</li> <li>Installation Tutorial (YouTube)</li> </ul>"},{"location":"getting_started/#ros-installation","title":"ROS Installation","text":"<ul> <li> <p>Refer to the ROS Noetic Installation Guide for Ubuntu.</p> </li> <li> <p>For a step-by-step tutorial, watch this ROS Noetic Installation Video.</p> </li> </ul>"},{"location":"getting_started/#tutorials","title":"Tutorials","text":"<p>Follow the ROS Noetic Tutorials for a comprehensive understanding of ROS concepts.</p> <ol> <li>Installing and Configuring Your ROS Environment</li> <li>Navigating the ROS Filesystem</li> <li>Creating a ROS Package</li> <li>Building a ROS Package</li> <li>Understanding ROS Nodes</li> <li>Understanding ROS Topics</li> <li>Understanding ROS Services and Parameters</li> <li>Using rqt_console and roslaunch</li> <li>Using rosed to edit files in ROS</li> <li>Creating a ROS msg and srv</li> <li>Writing a Simple Publisher and Subscriber (Python)</li> <li>Examining the Simple Publisher and Subscriber</li> <li>Writing a Simple Service and Client (Python)</li> </ol>"},{"location":"exercises/custom_service_client/","title":"Custom Service and Client","text":""},{"location":"exercises/custom_service_client/#objectives","title":"Objectives","text":"<ul> <li>You will create a service with a new definition to apply it on the screen.</li> <li>You will create a battery node that will contain a battery state.</li> <li>You will also create a LED panel node which will contain the state of three LEDs and will print every second this state. So you don\u2019t need to real LEDs for this activity.</li> <li>You will have to create a new service definition with one request containing the number of the LED and another number 0 or 1 to power off and on the LED. The response will simply contain a boolean flag to notify if the state of the LED could be successfully changed.</li> <li>When the battery is empty, you will send a request to the sever to ask for one LED to be powered on and when the batter is full, you will power off the LED. As you have no real battery here, you can just fake the battery state.</li> <li>Let\u2019s say that the battery will switch from a full state to an empty state every seven seconds, and then will switch back to a full state in three seconds.</li> </ul>"},{"location":"exercises/custom_service_client/#create-a-new-service-definition","title":"Create a new service definition","text":"<ul> <li>Create a new service definition in the <code>srv</code> folder of your package. The name of the service should be <code>SetLED.srv</code>.</li> <li>The request should contain two integers: the number of the LED (0, 1, or 2) and the state of the LED (0 for off and 1 for on).</li> <li>The response should contain a boolean flag to notify if the state of the LED could be successfully changed.</li> </ul> <pre><code>int64 led_number\nint64 state\n---\nbool success\n</code></pre>"},{"location":"exercises/custom_service_client/#update-the-packagexml-file","title":"Update the package.xml file","text":"<ul> <li> <p>Include the necessary dependencies in the <code>package.xml</code> file.</p> </li> <li> <p>Add the following lines to the <code>package.xml</code> file:</p> </li> </ul> <pre><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;\n&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n</code></pre>"},{"location":"exercises/custom_service_client/#update-the-cmakeliststxt-file","title":"Update the CMakeLists.txt file","text":"<ul> <li>Add the following lines to the <code>CMakeLists.txt</code> file:</li> </ul> <pre><code>find_package(catkin REQUIRED COMPONENTS\n  rospy\n  std_msgs\n  message_generation\n)\n\nadd_service_files(\n  FILES\n  SetLED.srv\n)\n\ngenerate_messages(\n  DEPENDENCIES std_msgs\n)\n\ncatkin_package(\n  CATKIN_DEPENDS message_runtime rospy std_msgs\n)\n</code></pre>"},{"location":"exercises/custom_service_client/#create-the-battery-node","title":"Create the Battery Node","text":"<ul> <li>Create a file named battery.py in the <code>src</code> folder of the <code>exercises</code> package.</li> </ul> <pre><code>cd ~/catkin_ws/src/exercises/src\ntouch battery.py\n</code></pre> <ul> <li>Open the file and add the following code:</li> </ul> <pre><code>#!/usr/bin/env python\nimport rospy\nfrom exercises.srv import SetLED\nfrom rospy import Timer, Duration\nfrom std_msgs.msg import Bool\n\nclass Battery:\n    def __init__(self):\n        rospy.init_node('battery_node')\n        self.is_full = True\n        rospy.loginfo(\"Battery node started (initially full).\")\n\n        self.on_time = 7\n        self.charge_time = 3\n        self.current_time = 0\n        self.cycle_time = 0\n\n        self.battery_clock()\n\n    def battery_clock(self):\n        while not rospy.is_shutdown():\n            self.current_time += 1\n            self.cycle_time += 1\n\n            if self.is_full:\n                if self.cycle_time &gt;= self.on_time:\n                    self.is_full = False\n                    rospy.loginfo(\"Battery is now empty.\")\n                    self.cycle_time = 0\n                    self.toggle_led(0, 1)\n                    self.toggle_led(1, 1)\n                    self.toggle_led(2, 1)\n                    # self.toggle_led(3, 1)\n            else:\n                if self.cycle_time &gt;= self.charge_time:\n                    self.is_full = True\n                    rospy.loginfo(\"Battery is now full.\")\n                    self.cycle_time = 0\n                    self.toggle_led(0, 0)\n                    self.toggle_led(1, 0)\n                    self.toggle_led(2, 0)\n\n            rospy.sleep(1)\n\n\n    def toggle_led(self, led_idx = 0,led_on = 0 ):\n        rospy.wait_for_service('set_led')\n        try:\n            client = rospy.ServiceProxy('set_led', SetLED)\n            resp = client(led_idx, led_on)\n            if resp.success:\n                rospy.loginfo(f\"Successfully set LED {led_idx} to {led_on}\")\n            else:\n                rospy.logwarn(\"Service call failed or invalid LED number.\")\n        except rospy.ServiceException as e:\n            rospy.logerr(f\"Service call exception: {e}\")\n\n\nif __name__ == '__main__':\n    Battery()\n</code></pre>"},{"location":"exercises/custom_service_client/#create-the-led-panel-node","title":"Create the LED Panel Node","text":"<ul> <li>Create a file named led_panel.py in the <code>src</code> folder of the <code>exercises</code> package.</li> </ul> <pre><code>cd ~/catkin_ws/src/exercises/src\ntouch led_panel.py\n</code></pre> <ul> <li>Open the file and add the following code:</li> </ul> <pre><code>#!/usr/bin/env python\nimport rospy\nfrom exercises.srv import SetLED, SetLEDResponse\n\nclass LEDPanel:\n    def __init__(self):\n        rospy.init_node('led_panel')\n        self.led_states = [0, 0, 0]\n\n        self.srv = rospy.Service('set_led', SetLED, self.handle_set_led)\n\n        rospy.Timer(rospy.Duration(1), self.print_states)\n\n        rospy.loginfo(\"LED panel service ready.\")\n        rospy.spin()\n\n    def handle_set_led(self, req):\n        if 0 &lt;= req.led_number &lt; len(self.led_states):\n            self.led_states[req.led_number] = req.state\n            rospy.loginfo(f\"LED {req.led_number} set to {req.state}\")\n            return SetLEDResponse(success=True)\n        else:\n            rospy.logwarn(f\"Invalid LED number: {req.led_number}\")\n            return SetLEDResponse(success=False)\n\n    def print_states(self, event):\n            rospy.loginfo(f\"LED states: {self.led_states}\")\n\nif __name__ == '__main__':\n    LEDPanel()\n</code></pre>"},{"location":"exercises/custom_service_client/#make-the-scripts-executable","title":"Make the scripts executable","text":"<pre><code>cd ~/catkin_ws/src/exercises/src\nchmod u+x battery.py\nchmod u+x led_panel.py\n</code></pre>"},{"location":"exercises/custom_service_client/#build-the-package","title":"Build the package","text":"<pre><code>cd ~/catkin_ws\ncatkin_make\n</code></pre>"},{"location":"exercises/publisher_subscriber/","title":"Number Publisher and Subscriber","text":""},{"location":"exercises/publisher_subscriber/#objectives","title":"Objectives","text":"<p>Create two nodes with the following features.</p> <ul> <li> <p>The first node number publisher will publish to a topic named <code>/number</code> with the message type, standard message int 64.</p> </li> <li> <p>The second node is a number counter containing a subscriber and a publisher. Every time it receives a number, it will add it to a counter, and every time it receives a number and increases the counter, it will also publish on the topic <code>/number_count</code> with standard message int 64. (You can write in Python/C++)</p> </li> </ul> <p></p>"},{"location":"exercises/publisher_subscriber/#creating-a-package","title":"Creating a package","text":"<ul> <li>Source the workspace</li> </ul> <pre><code>source ~/catkin_ws/devel/setup.bash\n</code></pre> <ul> <li>Create a package</li> </ul> <pre><code>cd ~/catkin_ws/src\ncatkin_create_pkg exercises std_msgs rospy\n</code></pre> <p>This will create a package named <code>exercises</code> with dependencies on <code>std_msgs</code> and <code>rospy</code>.</p>"},{"location":"exercises/publisher_subscriber/#create-the-publisher-node","title":"Create the publisher node","text":"<ul> <li>Create a file named number_publisher.py in the <code>src</code> folder of the <code>exercises</code> package.</li> </ul> <pre><code>cd ~/catkin_ws/src/exercises/src\ntouch number_publisher.py\n</code></pre> <ul> <li>Open the file and add the following code:</li> </ul> <pre><code>#!/usr/bin/env python\nimport rospy\nfrom std_msgs.msg import Int64\n\ndef publisher():\n    rospy.init_node('number_publisher', anonymous=True)\n    number_publisher = rospy.Publisher('/number', Int64, queue_size=10)\n\n    msg = Int64()\n    rate = rospy.Rate(1)\n    msg.data = 1\n\n    while not rospy.is_shutdown():\n        number_publisher.publish(msg)\n        print(\"Published number: \", msg.data)\n        rate.sleep()\n\nif __name__ == '__main__':\n    try:\n        publisher()\n    except rospy.ROSInterruptException:\n        pass\n</code></pre>"},{"location":"exercises/publisher_subscriber/#create-the-subscriber-node","title":"Create the subscriber node","text":"<ul> <li>Create a file named number_counter.py in the <code>src</code> folder of the <code>exercises</code> package.</li> </ul> <pre><code>cd ~/catkin_ws/src/exercises/src\ntouch number_counter.py\n</code></pre> <ul> <li>Open the file and add the following code:</li> </ul> <pre><code>#!/usr/bin/env python\nimport rospy\nfrom std_msgs.msg import Int64\n\nTOTAL = 0\n\ndef callback(data, counter_publisher):\n    global TOTAL\n    TOTAL += data.data\n    msg = Int64()\n    msg.data = TOTAL\n    counter_publisher.publish(msg)\n    print(\"Total count: \", msg.data)\n\ndef listener():\n    rospy.init_node('number_counter', anonymous=True)\n    counter_publisher = rospy.Publisher('/number_count', Int64, queue_size=10)\n    rospy.Subscriber(\"/number\", Int64, callback,counter_publisher)\n    rospy.spin()\n\nif __name__ == '__main__':\n    listener()\n</code></pre>"},{"location":"exercises/publisher_subscriber/#make-the-scripts-executable","title":"Make the scripts executable","text":"<pre><code>cd ~/catkin_ws/src/exercises/src\nchmod u+x number_publisher.py\nchmod u+x number_counter.py\n</code></pre>"},{"location":"exercises/publisher_subscriber/#build-the-package","title":"Build the package","text":"<pre><code>cd ~/catkin_ws\ncatkin_make\n</code></pre>"},{"location":"exercises/publisher_subscriber/#run-the-nodes","title":"Run the nodes","text":"<ul> <li>Open a terminal and run the roscore:</li> </ul> <pre><code>roscore\n</code></pre> <ul> <li>Open a new terminal and run the number publisher node:</li> </ul> <pre><code>source ~/catkin_ws/devel/setup.bash\nrosrun exercises number_publisher.py\n</code></pre> <ul> <li>Open a new terminal and run the number counter node:</li> </ul> <pre><code>source ~/catkin_ws/devel/setup.bash\nrosrun exercises number_counter.py\n</code></pre>"},{"location":"exercises/reset_service/","title":"Reset Service","text":""},{"location":"exercises/reset_service/#objectives","title":"Objectives","text":"<p>In the previous exercise, the number counter was subscribed to this topic. The node counter would add the number inside the message into an internal counter for every message received. It would publish the counter's value each time on a number count topic. Well, it would be great to ask the number count node to reset the counter at any time. Here, this is the exercise, where, inside the number_counter node, you will create a service server withe the service type: standard service set boolean.</p> <p></p>"},{"location":"exercises/reset_service/#add-the-service-server-to-the-number_counter-node","title":"Add the service server to the number_counter node","text":"<ul> <li>Open the file number_counter.py and change to the following code:</li> </ul> <pre><code>#!/usr/bin/env python\nimport rospy\nfrom std_msgs.msg import Int64\nfrom std_srvs.srv import SetBool\n\nTOTAL = 0\n\ndef handle_reset(req):\n    global TOTAL\n    TOTAL = 0\n    print(\"Total count reset to 0\")\n    return True, \"Total count reset to 0\"\n\ndef callback(data, counter_publisher):\n    global TOTAL\n    TOTAL += data.data\n    msg = Int64()\n    msg.data = TOTAL\n    counter_publisher.publish(msg)\n    print(\"Total count: \", msg.data)\n\ndef listener():\n    rospy.init_node('number_counter', anonymous=True)\n    counter_publisher = rospy.Publisher('/number_count', Int64, queue_size=10)\n    rospy.Service('reset_number_count', SetBool, handle_reset)\n    rospy.Subscriber(\"/number\", Int64, callback,counter_publisher)\n    rospy.spin()\n\nif __name__ == '__main__':\n    listener()\n</code></pre>"},{"location":"exercises/reset_service/#call-the-service","title":"Call the service","text":"<ul> <li>Open a new terminal and call the service:</li> </ul> <pre><code>rosservice call /reset_number_count True\n</code></pre> <ul> <li>You should see the message \"Total count reset to 0\" in the terminal where the number_counter node is running. The counter will be reset to 0.</li> </ul>"},{"location":"experiments/path_planning/gazebo/","title":"Gazebo Simulation for TurtleBot3","text":""},{"location":"experiments/path_planning/gazebo/#setting-up-the-environment","title":"Setting Up the Environment","text":"<ul> <li>Create a catkin workspace and clone the required repository</li> </ul> <pre><code>mkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/src/\ngit clone -b noetic https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git\ncd ~/catkin_ws &amp;&amp; catkin_make\n</code></pre> <ul> <li>Source the workspace</li> </ul> <pre><code>source ~/catkin_ws/devel/setup.bash\n</code></pre>"},{"location":"experiments/path_planning/gazebo/#launching-simulation-world","title":"Launching Simulation World","text":"<ul> <li>Launch the Gazebo simulation with the TurtleBot3 Burger model</li> </ul> <pre><code>export TURTLEBOT3_MODEL=burger\nroslaunch turtlebot3_gazebo turtlebot3_empty_world.launch\n</code></pre>"},{"location":"experiments/path_planning/gazebo/#operate-using-teleop","title":"Operate using Teleop","text":"<ul> <li>Open a new terminal and source the workspace</li> </ul> <pre><code>source ~/catkin_ws/devel/setup.bash\n</code></pre> <ul> <li>Set the model environment variable</li> </ul> <pre><code>export TURTLEBOT3_MODEL=burger\n</code></pre> <ul> <li>Launch the teleop node</li> </ul> <pre><code>roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch\n</code></pre> <ul> <li>You can follow the instructions in the terminal to control the robot using the keyboard.</li> </ul>"},{"location":"experiments/path_planning/gazebo/#reseting-the-simulation-world","title":"Reseting the Simulation World","text":"<ul> <li>If you want to reset the simulation world, you can use the following command in a new terminal:</li> </ul> <pre><code>rosservice call /gazebo/reset_world\n</code></pre> <ul> <li>You can also reset from the Gazebo GUI by selecting <code>Edit</code> -&gt; <code>Reset World</code>.</li> </ul>"},{"location":"experiments/path_planning/hardware/","title":"Hardware for TurtleBot3","text":""},{"location":"experiments/path_planning/hardware/#objectives","title":"Objectives","text":"<ul> <li>To control multiple TurtleBot3 robots through the ROS network.</li> </ul>"},{"location":"experiments/path_planning/hardware/#experimental-setup","title":"Experimental Setup","text":"<ul> <li>The master node (computer) and the control nodes (other computers) are connected to the same network.</li> <li>The master node is running the ROS master.</li> <li>The control nodes will be used to control the TurtleBot3 robots.</li> <li>All the TurtleBot3 robots are connected to the same network.</li> <li>Each TurtleBot3 robot has a unique IP address.</li> <li>Each TurtleBot3 robot is connected to a different control node.</li> </ul>"},{"location":"experiments/path_planning/hardware/#master-node-setup","title":"Master Node Setup","text":"<ul> <li>Start the ROS master node by running the following command on the master node:</li> </ul> <pre><code>roscore\n</code></pre>"},{"location":"experiments/path_planning/hardware/#control-node-setup","title":"Control Node Setup","text":"<ul> <li>Set the following environment variables on each control node:</li> </ul> <pre><code>export ROS_MASTER_URI=http://&lt;master_node_ip&gt;:11311\nexport ROS_HOSTNAME=&lt;control_node_ip&gt;\nexport TURTLEBOT3_MODEL=burger\n</code></pre> <ul> <li>Replace <code>&lt;master_node_ip&gt;</code> with the IP address of the master node and <code>&lt;control_node_ip&gt;</code> with the IP address of the control node.</li> <li>You can find the IP address of the nodes by running the following command on the nodes:</li> </ul> <pre><code>ifconfig\n</code></pre>"},{"location":"experiments/path_planning/hardware/#turtlebot3-setup","title":"TurtleBot3 Setup","text":"<ul> <li>Power on the TurtleBot3 robot by connecting the battery.</li> <li>The robot will automatically boot up and connect to the network.</li> <li>Open a terminal on either the master node or the control node and ssh into the TurtleBot3 robot:</li> </ul> <pre><code>ssh ubuntu@&lt;robot_ip&gt;\n</code></pre> <ul> <li>Replace <code>&lt;robot_ip&gt;</code> with the IP address of the TurtleBot3 robot.</li> <li> <p>You will be prompted to enter the password. The default password is <code>turtlebot</code>.</p> </li> <li> <p>Set the following environment variables on the TurtleBot3 robot:</p> </li> </ul> <pre><code>export ROS_MASTER_URI=http://&lt;master_node_ip&gt;:11311\nexport ROS_HOSTNAME=&lt;robot_ip&gt;\nexport TURTLEBOT3_MODEL=burger\n</code></pre> <ul> <li>Replace <code>&lt;master_node_ip&gt;</code> with the IP address of the master node and <code>&lt;robot_ip&gt;</code> with the IP address of the TurtleBot3 robot.</li> </ul> <p>Generally these configurations are set in the <code>~/.bashrc</code> file, so they are automatically set when the terminal is opened.</p> <ul> <li>Bring up TurtleBot3 robot, this callibrates the robot and starts the ROS nodes:</li> </ul> <pre><code>roslaunch turtlebot3_bringup turtlebot3_robot.launch\n</code></pre>"},{"location":"experiments/path_planning/hardware/#controling-the-turtlebot3-robot","title":"Controling the TurtleBot3 Robot","text":"<ul> <li>Each TurtleBot3 robot is namespaced with unique identifiers.</li> <li>Here they are named <code>tb3_1</code>,<code>tb3_2</code>,<code>tb3_3</code>,<code>tb3_4</code>.</li> <li>For example, to control the first robot, you have to publish to the <code>/tb3_1/cmd_vel</code> topic.</li> <li>To get Odometry data from the second robot, you have to subscribe to the <code>/tb3_2/odom</code> topic.</li> <li>To get a list of all the topics, you can run the following command on any of the nodes:</li> </ul> <pre><code>rostopic list\n</code></pre> <ul> <li>Inorder to control the TurtleBot3 robot using teleop, you have to namespace the teleop node with the robot name.</li> <li>To do this the launch file should be modified to include the namespace.</li> <li>The launch file is located at <code>/opt/ros/noetic/share/turtlebot3_teleop/launch turtlebot3_teleop_key.launch</code>.</li> <li>To view the launch file, run the following command:</li> </ul> <pre><code>cat /opt/ros/noetic/share/turtlebot3_teleop/launch/turtlebot3_teleop_key.launch\n</code></pre> <ul> <li>Now edit the launch file to remap the topic with the namespace.</li> <li>The modified launch file should look like this:</li> </ul> <pre><code>&lt;launch&gt;\n  &lt;arg name=\"model\" default=\"$(env TURTLEBOT3_MODEL)\" doc=\"model type [burger, waffle, waffle_pi]\"/&gt;\n  &lt;param name=\"model\" value=\"$(arg model)\"/&gt;\n\n  &lt;!-- turtlebot3_teleop_key already has its own built in velocity smoother --&gt;\n  &lt;node pkg=\"turtlebot3_teleop\" type=\"turtlebot3_teleop_key\" name=\"turtlebot3_teleop_keyboard\"  output=\"screen\"&gt;\n    &lt;remap from=\"/cmd_vel\" to=\"$(arg namespace)/cmd_vel\" /&gt;\n  &lt;/node&gt;\n&lt;/launch&gt;\n</code></pre> <ul> <li>Now save the file and run the following command to launch the teleop node:</li> </ul> <pre><code>roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch namespace:=/tb3_3\n</code></pre> <ul> <li>Now you can control the third TurtleBot3 robot using the keyboard.</li> </ul>"},{"location":"experiments/path_planning/introduction/","title":"Path Planning with Turtlebot3","text":""},{"location":"experiments/path_planning/introduction/#objectives","title":"Objectives","text":"<ul> <li>Understand the basic hardware and software architecture of TurtleBot3.</li> <li>Learn how to set up and simulate TurtleBot3 in Gazebo for path planning experiments.</li> <li>Practice commanding the TurtleBot3 to follow a trajectory without using the built-in ROS Navigation Stack.</li> <li>Transition from simulation to a physical TurtleBot3 robot for real-world testing and comparison.</li> </ul>"},{"location":"experiments/path_planning/introduction/#theory","title":"Theory","text":""},{"location":"experiments/path_planning/introduction/#introduction-to-turtlebot3","title":"Introduction to TurtleBot3","text":"<p>TurtleBot3 is a small, affordable, and fully open-source ROS-based mobile robot. It typically includes:</p> <ul> <li>Single-board Computer: A Raspberry Pi running Ubuntu and ROS.</li> <li>OpenCR Board: Handles direct motor control, sensor reading, and low-level feedback loops.</li> <li>2WD Differential-Drive Base: Uses two DC motors for locomotion.</li> <li>LIDAR Sensor: Provides distance measurement and environment mapping.</li> </ul> <p>By publishing velocity commands on the <code>/cmd_vel</code> topic, you can manually steer the robot in Gazebo (a 3D physics simulator) and eventually apply the same concept on physical hardware. This approach provides deeper insight into differential-drive kinematics, odometry, and the differences between simulated and real-world performance.</p>"},{"location":"experiments/path_planning/introduction/#key-features-of-turtlebot3","title":"Key Features of TurtleBot3","text":"<ul> <li>Modular Architecture: The same code typically works both in simulation (Gazebo) and on real hardware.</li> <li>Differential Drive: Simplifies forward and turn commands; however, it can be prone to wheel slip.</li> <li>ROS Topics:</li> <li><code>/cmd_vel</code>: Publishes <code>geometry_msgs/Twist</code> messages to set linear and angular velocities.</li> <li><code>/odom</code>: Provides odometry updates for position and heading estimation.</li> <li>Open-Source Tools: The entire TurtleBot3 software stack (URDF files, Gazebo worlds, driver nodes) is freely available.</li> </ul> <p>Note In advanced projects, you might use the standard Navigation Stack (such as <code>move_base</code> and costmaps). Here, however, we bypass it to understand how raw velocity commands influence a differential-drive robot. For this exercise, ROS Noetic is preferred due to its extended support for TurtleBot3 in both simulations and hardware setups.</p>"},{"location":"experiments/path_planning/introduction/#references","title":"References","text":"<ul> <li>TurtleBot3 E-Manual (Robotis)</li> <li>TurtleBot3 ROS Wiki</li> <li>ROS Tutorial: Publisher/Subscriber</li> </ul>"},{"location":"experiments/path_planning/introduction/#installation-and-setup","title":"Installation and Setup","text":"<ul> <li> <p>Make sure to follow the instructions corresponding to your ROS version, this document is based on ROS Noetic.</p> </li> <li> <p>Install Turtlebot3 Packages required for the Hardware and Simulation Setups by following the steps in the TurtleBot3 Quick Start</p> </li> <li> <p>Set up the simulation environment by following the steps in the TurtleBot3 Gazebo Simulation section of the E-Manual.</p> </li> </ul>"}]}